{
  "version": 3,
  "sources": ["../../../cloudflare/chatbot-proxy-worker.js"],
  "sourceRoot": "C:\\Users\\ASUS\\Desktop\\StartUp\\ngt-chatbot-proxy\\.wrangler\\tmp\\deploy-81dbvu",
  "sourcesContent": ["/**\r\n * NGT Backend Proxy Worker\r\n *\r\n * Proxies ALL HTTPS requests from GitHub Pages to the backend services on a\r\n * DigitalOcean droplet.  The browser talks HTTPS \u2192 Worker \u2192 HTTP \u2192 backend.\r\n *\r\n * Path-prefix routing:\r\n *   /chatbot/*  \u2192 FastAPI chatbot on BACKEND_IP:CHATBOT_PORT  (strips /chatbot)\r\n *   /contact/*  \u2192 Express contact API on BACKEND_IP:CONTACT_PORT (strips /contact)\r\n *\r\n * Cloudflare Workers block outbound fetch() to raw IP addresses (error 1003).\r\n * Workaround: use nip.io wildcard DNS so the Worker fetches a proper hostname\r\n * (e.g. 165-245-177-103.nip.io) which resolves to the same IP but bypasses\r\n * Cloudflare's \"Direct IP access not allowed\" check.\r\n *\r\n * Environment variables (set in wrangler.toml [vars] or dashboard):\r\n *   BACKEND_IP    \u2013 DigitalOcean droplet public IPv4, e.g. 165.245.177.103\r\n *   CHATBOT_PORT  \u2013 chatbot backend port, e.g. 8000\r\n *   CONTACT_PORT  \u2013 contact API port, e.g. 3001\r\n */\r\nexport default {\r\n  async fetch(request, env) {\r\n    // \u2500\u2500 Configuration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    const BACKEND_IP   = env.BACKEND_IP   || '165.245.177.103';\r\n    const CHATBOT_PORT = env.CHATBOT_PORT || '8000';\r\n    const CONTACT_PORT = env.CONTACT_PORT || '3001';\r\n\r\n    // Convert IP to a nip.io hostname so Cloudflare doesn't block it\r\n    // 165.245.177.103 \u2192 165-245-177-103.nip.io (resolves to same IP)\r\n    const BACKEND_HOST = BACKEND_IP.replace(/\\./g, '-') + '.nip.io';\r\n\r\n    // Service routing table: path prefix \u2192 backend port\r\n    const SERVICES = {\r\n      '/chatbot': CHATBOT_PORT,\r\n      '/contact': CONTACT_PORT,\r\n    };\r\n\r\n    const ALLOWED_ORIGINS = [\r\n      'https://nexgenteck.github.io',\r\n      'https://muhammadhasaan82.github.io',\r\n      'http://localhost:5173',\r\n      'http://localhost:4173',\r\n    ];\r\n\r\n    // \u2500\u2500 CORS helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    const origin = request.headers.get('Origin') || '';\r\n    const defaultOrigin = 'https://nexgenteck.github.io';\r\n    const corsOrigin = ALLOWED_ORIGINS.includes(origin) ? origin : defaultOrigin;\r\n\r\n    const corsHeaders = {\r\n      'Access-Control-Allow-Origin':  corsOrigin,\r\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',\r\n      'Access-Control-Max-Age':       '86400',\r\n    };\r\n\r\n    // \u2500\u2500 Preflight \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    if (request.method === 'OPTIONS') {\r\n      return new Response(null, { status: 204, headers: corsHeaders });\r\n    }\r\n\r\n    // \u2500\u2500 Route to the correct backend service \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    const incoming = new URL(request.url);\r\n    const path     = incoming.pathname;\r\n\r\n    // Find matching service by path prefix\r\n    let targetPort  = null;\r\n    let strippedPath = path;\r\n\r\n    for (const [prefix, port] of Object.entries(SERVICES)) {\r\n      if (path === prefix || path.startsWith(prefix + '/')) {\r\n        targetPort   = port;\r\n        strippedPath = path.slice(prefix.length) || '/';\r\n        break;\r\n      }\r\n    }\r\n\r\n    // No matching service prefix \u2192 return helpful info\r\n    if (!targetPort) {\r\n      return new Response(\r\n        JSON.stringify({\r\n          status: 'ok',\r\n          worker: 'ngt-backend-proxy',\r\n          services: Object.keys(SERVICES),\r\n          usage: 'Prefix your request path with /chatbot or /contact',\r\n        }),\r\n        {\r\n          status: 200,\r\n          headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n        },\r\n      );\r\n    }\r\n\r\n    // \u2500\u2500 Build target URL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    const targetUrl = `http://${BACKEND_HOST}:${targetPort}${strippedPath}${incoming.search}`;\r\n\r\n    // \u2500\u2500 Build clean headers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    //    Only forward the headers the backend actually needs.\r\n    //    Do NOT set a custom Host header \u2013 let it default to the IP:port\r\n    //    from the URL so Cloudflare passes the request straight through.\r\n    const headers = new Headers();\r\n    headers.set('Content-Type', request.headers.get('Content-Type') || 'application/json');\r\n    headers.set('Accept', request.headers.get('Accept') || 'application/json');\r\n\r\n    // Carry the real client IP for logging\r\n    const clientIp = request.headers.get('cf-connecting-ip');\r\n    if (clientIp) headers.set('X-Forwarded-For', clientIp);\r\n\r\n    // \u2500\u2500 Proxy the request \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    try {\r\n      const backendResponse = await fetch(targetUrl, {\r\n        method:  request.method,\r\n        headers: headers,\r\n        body:    ['GET', 'HEAD'].includes(request.method) ? undefined : request.body,\r\n      });\r\n\r\n      // Attach CORS headers to the backend's response\r\n      const responseHeaders = new Headers(backendResponse.headers);\r\n      for (const [key, value] of Object.entries(corsHeaders)) {\r\n        responseHeaders.set(key, value);\r\n      }\r\n\r\n      return new Response(backendResponse.body, {\r\n        status:     backendResponse.status,\r\n        statusText: backendResponse.statusText,\r\n        headers:    responseHeaders,\r\n      });\r\n    } catch (err) {\r\n      return new Response(\r\n        JSON.stringify({ error: 'Backend unreachable', detail: err.message }),\r\n        {\r\n          status:  502,\r\n          headers: { 'Content-Type': 'application/json', ...corsHeaders },\r\n        },\r\n      );\r\n    }\r\n  },\r\n};\r\n"],
  "mappings": ";AAoBA,IAAO,+BAAQ;AAAA,EACb,MAAM,MAAM,SAAS,KAAK;AAExB,UAAM,aAAe,IAAI,cAAgB;AACzC,UAAM,eAAe,IAAI,gBAAgB;AACzC,UAAM,eAAe,IAAI,gBAAgB;AAIzC,UAAM,eAAe,WAAW,QAAQ,OAAO,GAAG,IAAI;AAGtD,UAAM,WAAW;AAAA,MACf,YAAY;AAAA,MACZ,YAAY;AAAA,IACd;AAEA,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,UAAM,SAAS,QAAQ,QAAQ,IAAI,QAAQ,KAAK;AAChD,UAAM,gBAAgB;AACtB,UAAM,aAAa,gBAAgB,SAAS,MAAM,IAAI,SAAS;AAE/D,UAAM,cAAc;AAAA,MAClB,+BAAgC;AAAA,MAChC,gCAAgC;AAAA,MAChC,gCAAgC;AAAA,MAChC,0BAAgC;AAAA,IAClC;AAGA,QAAI,QAAQ,WAAW,WAAW;AAChC,aAAO,IAAI,SAAS,MAAM,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAAA,IACjE;AAGA,UAAM,WAAW,IAAI,IAAI,QAAQ,GAAG;AACpC,UAAM,OAAW,SAAS;AAG1B,QAAI,aAAc;AAClB,QAAI,eAAe;AAEnB,eAAW,CAAC,QAAQ,IAAI,KAAK,OAAO,QAAQ,QAAQ,GAAG;AACrD,UAAI,SAAS,UAAU,KAAK,WAAW,SAAS,GAAG,GAAG;AACpD,qBAAe;AACf,uBAAe,KAAK,MAAM,OAAO,MAAM,KAAK;AAC5C;AAAA,MACF;AAAA,IACF;AAGA,QAAI,CAAC,YAAY;AACf,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,UAAU,OAAO,KAAK,QAAQ;AAAA,UAC9B,OAAO;AAAA,QACT,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,oBAAoB,GAAG,YAAY;AAAA,QAChE;AAAA,MACF;AAAA,IACF;AAGA,UAAM,YAAY,UAAU,YAAY,IAAI,UAAU,GAAG,YAAY,GAAG,SAAS,MAAM;AAMvF,UAAM,UAAU,IAAI,QAAQ;AAC5B,YAAQ,IAAI,gBAAgB,QAAQ,QAAQ,IAAI,cAAc,KAAK,kBAAkB;AACrF,YAAQ,IAAI,UAAU,QAAQ,QAAQ,IAAI,QAAQ,KAAK,kBAAkB;AAGzE,UAAM,WAAW,QAAQ,QAAQ,IAAI,kBAAkB;AACvD,QAAI,SAAU,SAAQ,IAAI,mBAAmB,QAAQ;AAGrD,QAAI;AACF,YAAM,kBAAkB,MAAM,MAAM,WAAW;AAAA,QAC7C,QAAS,QAAQ;AAAA,QACjB;AAAA,QACA,MAAS,CAAC,OAAO,MAAM,EAAE,SAAS,QAAQ,MAAM,IAAI,SAAY,QAAQ;AAAA,MAC1E,CAAC;AAGD,YAAM,kBAAkB,IAAI,QAAQ,gBAAgB,OAAO;AAC3D,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,WAAW,GAAG;AACtD,wBAAgB,IAAI,KAAK,KAAK;AAAA,MAChC;AAEA,aAAO,IAAI,SAAS,gBAAgB,MAAM;AAAA,QACxC,QAAY,gBAAgB;AAAA,QAC5B,YAAY,gBAAgB;AAAA,QAC5B,SAAY;AAAA,MACd,CAAC;AAAA,IACH,SAAS,KAAK;AACZ,aAAO,IAAI;AAAA,QACT,KAAK,UAAU,EAAE,OAAO,uBAAuB,QAAQ,IAAI,QAAQ,CAAC;AAAA,QACpE;AAAA,UACE,QAAS;AAAA,UACT,SAAS,EAAE,gBAAgB,oBAAoB,GAAG,YAAY;AAAA,QAChE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
